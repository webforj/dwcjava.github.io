"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[5841],{3213:(a,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"data-binding/validation/jakarta-validation","title":"Jakarta Validation","description":"Java Bean Validation is widely recognized as the standard for integrating validation logic into Java applications. It utilizes a uniform approach to validation by allowing developers to annotate domain model properties with declarative validation constraints. These constraints are enforced at runtime, with options for both built-in and custom-defined rules.","source":"@site/docs/data-binding/validation/jakarta-validation.md","sourceDirName":"data-binding/validation","slug":"/data-binding/validation/jakarta-validation","permalink":"/docs/data-binding/validation/jakarta-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/webforj/webforj-docs/tree/website/docs/data-binding/validation/jakarta-validation.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Jakarta Validation"},"sidebar":"documentationSidebar","previous":{"title":"Triggers","permalink":"/docs/data-binding/validation/triggers"},"next":{"title":"Transformation","permalink":"/docs/data-binding/transformation"}}');var i=t(4848),o=t(8453);const r={sidebar_position:6,title:"Jakarta Validation"},s=void 0,d={},l=[{value:"Installation",id:"installation",level:2},{value:"The <code>JakartaValidator</code>",id:"the-jakartavalidator",level:2},{value:"Activating <code>JakartaValidator</code>",id:"activating-jakartavalidator",level:3},{value:"Defining constraints for bean properties",id:"defining-constraints-for-bean-properties",level:3}];function c(a){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...a.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:"https://beanvalidation.org/",children:"Java Bean Validation"})," is widely recognized as the standard for integrating validation logic into Java applications. It utilizes a uniform approach to validation by allowing developers to annotate domain model properties with declarative validation constraints. These constraints are enforced at runtime, with options for both built-in and custom-defined rules."]}),"\n",(0,i.jsxs)(e.p,{children:["webforJ seamlessly integrates with Bean Validation through the ",(0,i.jsx)(e.code,{children:"JakartaValidator"})," adapter, providing robust support out of the box."]}),"\n",(0,i.jsx)(e.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsxs)(e.p,{children:["It's necessary to include a compatible implementation, such as ",(0,i.jsx)(e.a,{href:"https://hibernate.org/validator/",children:"Hibernate Validator"}),", in your classpath. If your environment doesn't come with this implementation by default, you can add it manually by using the following Maven dependencies:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>8.0.1.Final</version>\n</dependency>\n<dependency>\n    <groupId>org.glassfish.expressly</groupId>\n    <artifactId>expressly</artifactId>\n    <version>5.0.0</version>\n</dependency>\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"the-jakartavalidator",children:["The ",(0,i.jsx)(e.code,{children:"JakartaValidator"})]}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"JakartaValidator"})," class serves as an adapter, bridging the webforJ binding context with Jakarta Validation. This integration enables the use of complex validation rules directly via annotations in the bean class."]}),"\n",(0,i.jsxs)(e.h3,{id:"activating-jakartavalidator",children:["Activating ",(0,i.jsx)(e.code,{children:"JakartaValidator"})]}),"\n",(0,i.jsxs)(e.p,{children:["To activate the ",(0,i.jsx)(e.code,{children:"JakartaValidator"})," across the entire context, you typically use the ",(0,i.jsx)(e.code,{children:"useJakartaValidator"})," parameter when constructing the ",(0,i.jsx)(e.code,{children:"BindingContext"}),"."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"BindingContext<User> context = new BindingContext<>(User.class, true);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"defining-constraints-for-bean-properties",children:"Defining constraints for bean properties"}),"\n",(0,i.jsx)(e.p,{children:"Annotation-based constraints are directly applied within the bean class to specify validation conditions, as illustrated in the example below:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Hero {\n  @NotEmpty(message = "Name cannot be empty")\n  @Length(min = 3, max = 20)\n  private String name;\n\n  @NotEmpty(message = "Unspecified power")\n  @Pattern(regexp = "Fly|Invisible|LaserVision|Speed|Teleportation", message = "Invalid power")\n  private String power;\n\n  // getters and setters\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Such constraints are as effective as those set programmatically during the binding initialization, ensuring consistent validation outcomes."}),"\n",(0,i.jsx)(e.admonition,{type:"warning",children:(0,i.jsxs)(e.p,{children:["Currently, the ",(0,i.jsx)(e.code,{children:"JakartaValidator"})," only recognizes constraints that are directly assigned to properties and ignores any validations not directly associated with properties."]})})]})}function p(a={}){const{wrapper:e}={...(0,o.R)(),...a.components};return e?(0,i.jsx)(e,{...a,children:(0,i.jsx)(c,{...a})}):c(a)}},8453:(a,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var n=t(6540);const i={},o=n.createContext(i);function r(a){const e=n.useContext(o);return n.useMemo((function(){return"function"==typeof a?a(e):{...e,...a}}),[e,a])}function s(a){let e;return e=a.disableParentContext?"function"==typeof a.components?a.components(i):a.components||i:r(a.components),n.createElement(o.Provider,{value:e},a.children)}}}]);