"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[4574],{358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"architecture/architecture","title":"Client/Server Interaction","description":"The following section discussed various performance qualities and best practices for webforj, as well as implementation details for the framework.","source":"@site/docs/architecture/architecture.md","sourceDirName":"architecture","slug":"/architecture/","permalink":"/docs/architecture/","draft":false,"unlisted":false,"editUrl":"https://github.com/webforj/webforj-docs/tree/website/docs/architecture/architecture.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Client/Server Interaction"},"sidebar":"documentationSidebar","previous":{"title":"Architecture","permalink":"/docs/architecture/overview"},"next":{"title":"BBj Controls and webforJ Components","permalink":"/docs/architecture/controls-components"}}');var i=n(4848),o=n(8453);const s={sidebar_position:5,title:"Client/Server Interaction"},a=void 0,c={},l=[{value:"1. Server to client",id:"1-server-to-client",level:2},{value:"2. Client to server",id:"2-client-to-server",level:2},{value:"3. Server to client to server (round trip)",id:"3-server-to-client-to-server-round-trip",level:2},{value:"Improve performance",id:"improve-performance",level:2},{value:"Caching",id:"caching",level:2},{value:"Loading time",id:"loading-time",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"The following section discussed various performance qualities and best practices for webforj, as well as implementation details for the framework."}),"\n",(0,i.jsx)(t.p,{children:"When creating an application in webforj, the client and the server work together to manipulate data between client and server can be broken down into the broad categories:"}),"\n",(0,i.jsx)(t.h2,{id:"1-server-to-client",children:"1. Server to client"}),"\n",(0,i.jsxs)(t.p,{children:["webforJ methods such as ",(0,i.jsx)(t.code,{children:"setText()"})," are included in this category. webforJ application running on the server sends data to the client without waiting for a response. webforJ automatically optimizes batches of operations in this category to improve performance."]}),"\n",(0,i.jsx)(t.h2,{id:"2-client-to-server",children:"2. Client to server"}),"\n",(0,i.jsxs)(t.p,{children:["This category covers event traffic, such as a ",(0,i.jsx)(t.code,{children:"Button.onClick()"})," method. For the most part, the client sends events to the server without waiting for any response. The event object typically contains additional parameters relating to the event, such as the hashcode. Because this information is delivered to the server as part of the act of delivering the event, it is immediately available to the program as soon as the event is received."]}),"\n",(0,i.jsx)(t.h2,{id:"3-server-to-client-to-server-round-trip",children:"3. Server to client to server (round trip)"}),"\n",(0,i.jsxs)(t.p,{children:["Round trips are performed when the application queries the client for some dynamic information that cannot be cached on the server. Methods such as ",(0,i.jsx)(t.code,{children:"Label.getText()"})," and ",(0,i.jsx)(t.code,{children:"Checkbox.isChecked()"})," fall into this category. When a webforj application executes a line such as ",(0,i.jsx)(t.code,{children:"String title = myLabel.getText()"}),", it comes to a complete standstill while the server sends that request to the client, then waits for the client to send the response back."]}),"\n",(0,i.jsx)(t.p,{children:"If the application sends several messages to the client that don't require a response (category 1), followed by a single message that requires a round trip (category 3), the application must wait for the client to process all pending messages, then respond to the final message that requires a response. In some cases, this can add a delay. If that round trip had not been introduced, the client would have been able to continue working through processing those backlogged messages while the application running on the server moved on to new work."}),"\n",(0,i.jsx)(t.h2,{id:"improve-performance",children:"Improve performance"}),"\n",(0,i.jsx)(t.p,{children:"It is possible to significantly improve application responsiveness by avoiding the third category's round trips as much as possible. For example, changing the ComboBox's onSelect functionality from this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"private void comboBoxSelect(ListSelectEvent ev){\r\n    ComboBox component = (ComboBox) ev.getComponent();\r\n\r\n    // Goes to the client\r\n    int selected = component.getSelectedIndex();\r\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"to the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"private void comboBoxSelect(ListSelectEvent ev){\r\n    //Gets value from the event\r\n    int selected = ev.getSelectedIndex();\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the first snippet, ",(0,i.jsx)(t.code,{children:"ComboBox.getSelectedIndex()"})," being performed on the component forces a round trip back to the client, introducing a delay. In the second version, using the event's ",(0,i.jsx)(t.code,{children:"ListSelectEvent.getSelectedIndex()"})," method retrieves the value that was delivered to the server as part of the original event."]}),"\n",(0,i.jsx)(t.h2,{id:"caching",children:"Caching"}),"\n",(0,i.jsx)(t.p,{children:"webforJ further optimizes performance by utilizing caching. In general, two types of data exist in this context: data that the user can directly change, and data that cannot be changed by the user. In the first case, when retrieving the information that users will directly interact with, it is necessary to query the server for this information."}),"\n",(0,i.jsx)(t.p,{children:"However, information which cannot be changed by the user can be cached to avoid additional performance hits. This ensures that a round trip does not need to be made unnecessarily, providing a more efficient user experience. webforJ optimizes applications in this manner to ensure optimal performance."}),"\n",(0,i.jsx)(t.h2,{id:"loading-time",children:"Loading time"}),"\n",(0,i.jsxs)(t.p,{children:["When the user launches a webforj app, it loads\r\njust a tiny chunk (only about 2.5kB gzip) of JavaScript to bootstrap the session.\r\nAfter that, it dynamically downloads individual messages, or chunks of\r\nJavaScript, on-demand as the application uses the corresponding\r\nfunctionality. For example, the server only sends the client the JavaScript\r\nnecessary to build a webforj ",(0,i.jsx)(t.code,{children:"Button"})," once \u2014 when the application creates its\r\nfirst ",(0,i.jsx)(t.code,{children:"Button"})," component. This results in measurable improvements to the initial\r\nload time, which results in a better user experience."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);