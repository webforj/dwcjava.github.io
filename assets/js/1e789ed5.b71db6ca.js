"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[9163],{99622:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"advanced/browser-history","title":"Browser History","description":"The BrowserHistory class in webforJ provides a high-level API to interact with the browser\'s history. Browser history allows web applications to keep track of the user\'s navigation within the app. By leveraging browser history, developers can enable features like back and forward navigation, state preservation, and dynamic URL management without requiring full-page reloads.","source":"@site/docs/advanced/browser-history.md","sourceDirName":"advanced","slug":"/advanced/browser-history","permalink":"/docs/advanced/browser-history","draft":false,"unlisted":false,"editUrl":"https://github.com/webforj/webforj-docs/tree/website/docs/advanced/browser-history.md","tags":[],"version":"current","frontMatter":{"title":"Browser History"},"sidebar":"documentationSidebar","previous":{"title":"Interval","permalink":"/docs/advanced/interval"},"next":{"title":"Error Handling","permalink":"/docs/advanced/error-handling"}}');var s=t(74848),r=t(28453);const a={title:"Browser History"},o=void 0,c={},h=[{value:"Navigating through history",id:"navigating-through-history",level:2},{value:"Initializing or retrieving a history instance",id:"initializing-or-retrieving-a-history-instance",level:3},{value:"Managing history",id:"managing-history",level:3},{value:"Accessing and updating URL",id:"accessing-and-updating-url",level:2},{value:"Managing state",id:"managing-state",level:2},{value:"Listening for state changes",id:"listening-for-state-changes",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," class in webforJ provides a high-level API to interact with the browser's history. Browser history allows web applications to keep track of the user's navigation within the app. By leveraging browser history, developers can enable features like back and forward navigation, state preservation, and dynamic URL management without requiring full-page reloads."]}),"\n",(0,s.jsx)(n.h2,{id:"navigating-through-history",children:"Navigating through history"}),"\n",(0,s.jsxs)(n.p,{children:["Managing the browser's history is a core feature for of most web apps. The ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," API enables developers to control how users navigate through the pages and states of their applications, mimicking or altering the standard browser behavior."]}),"\n",(0,s.jsx)(n.h3,{id:"initializing-or-retrieving-a-history-instance",children:"Initializing or retrieving a history instance"}),"\n",(0,s.jsxs)(n.p,{children:["To use the ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," API, you have two main options for obtaining a history instance:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Creating a new history object"}),": If you are working independently of a routing context, you can create a new instance of the ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," class directly."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"BrowserHistory history = new BrowserHistory();\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach is suitable for scenarios where you need to manage history explicitly outside of a routing framework."}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Retrieving the history from the ",(0,s.jsx)(n.code,{children:"Router"})]})," : If your app uses webforJ's ",(0,s.jsx)(n.a,{href:"../routing/overview",children:"routing solution"}),", the ",(0,s.jsx)(n.code,{children:"Router"})," component creates and manages a shared ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," instance. You can access this instance directly from the router, ensuring a consistent history management approach across your app."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"BrowserHistory history = Router.getCurrent().getHistory();\n"})}),"\n",(0,s.jsx)(n.p,{children:"This method is recommended when your app relies on routing, as it maintains consistency in history management across all views and navigation actions."}),"\n",(0,s.jsx)(n.h3,{id:"managing-history",children:"Managing history"}),"\n",(0,s.jsx)(n.p,{children:"The following methods can be used for history navigation in a webforJ app:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"back()"}),": Moves the browser history back by one step, simulating a user pressing the back button in their browser. If there are no more entries in the history stack, it stays on the current page."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"history.back();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"forward()"}),": Moves the browser history forward by one step, simulating a user pressing the forward button in their browser. This works only if there\u2019s an entry ahead in the history stack."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"history.forward();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"go(int index)"}),": Navigates to a specific point in the history stack based on an index. A positive number moves forward, a negative number moves backward, and zero reloads the current page. This method provides more granular control compared to ",(0,s.jsx)(n.code,{children:"back()"})," and ",(0,s.jsx)(n.code,{children:"forward()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"history.go(-2); // Moves back by two entries in the history stack\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"size()"}),": Retrieves the total number of entries in the session history stack including the currently loaded page. This can be useful for understanding the user's navigation path or for implementing custom navigation controls."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'int historySize = history.size();\nSystem.out.println("History Length: " + historySize);\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getLocation()"}),": Returns the current URL path relative to the apps's origin. This method helps developers fetch the current path, which is useful for managing URL-based routing in single-page applications."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Optional<Location> location = history.getLocation();\nlocation.ifPresent(loc -> System.out.println("Current Path: " + loc.getFullURI()));\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Understanding how to navigate efficiently is the cornerstone of building dynamic applications. Once you have the fundamentals of navigation, it's essential to know how to access and update the URLs associated with these navigation events."}),"\n",(0,s.jsx)(n.h2,{id:"accessing-and-updating-url",children:"Accessing and updating URL"}),"\n",(0,s.jsxs)(n.p,{children:["A core aspect of navigating and managing browser history is being able to access and update the current URL path efficiently. This is essential in modern web apps, where URL changes correspond to different views or states within the app. The ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," API offers a simple way to retrieve and manipulate the current path relative to the app's root."]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["webforJ ",(0,s.jsx)(n.code,{children:"Router"})]}),(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsxs)(n.a,{href:"../routing/overview",children:[(0,s.jsx)(n.code,{children:"Router"})," article"]})," to learn more about comprehensive URL and route management"]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getLocation()"})," retrieves the current URL path relative to the app's origin. The ",(0,s.jsx)(n.code,{children:"getLocation()"})," method returns an ",(0,s.jsx)(n.code,{children:"Optional<Location>"}),", allowing you to obtain the path portion of the URL without the domain."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Optional<Location> location = history.getLocation();\nlocation.ifPresent(loc -> System.out.println("Current Path: " + loc.getFullURI()));\n'})}),"\n",(0,s.jsx)(n.h2,{id:"managing-state",children:"Managing state"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BrowserHistory"})," lets you save and manage custom state information using ",(0,s.jsx)(n.code,{children:"pushState()"})," and ",(0,s.jsx)(n.code,{children:"replaceState()"})," methods. By using state management methods, you can control what information is stored as part of the history entry, which helps in maintaining a consistent user experience when navigating back and forth within your app. The following methods can be used to manage state in your webforJ app."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pushState(Object state, Location location)"}),": Adds a new entry to the history stack. Accepts a state object and a ",(0,s.jsx)(n.code,{children:"Location"})," object representing the new URL."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Location location = new Location("/new-page");\nhistory.pushState(myStateObject, location);\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"replaceState(Object state, Location location)"}),": Replaces the current history entry. This doesn't create a new entry in the stack like the above method."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Location location = new Location("/updated-page");\nhistory.replaceState(myStateObject, location);\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getState(Class<T> classOfT)"}),": Retrieves the state object associated with the current history entry. This method returns an Optional containing the state object, which is deserialized into the specified class."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Optional<MyState> currentState = history.getState(MyState.class);\ncurrentState.ifPresent(state -> System.out.println("Current Page: " + state.getViewName()));\n'})}),"\n",(0,s.jsx)(n.h3,{id:"listening-for-state-changes",children:"Listening for state changes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"BrowserHistory"})," class provides the ability to register event listeners that respond to changes in the history state."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"addHistoryStateChangeListener(EventListener<HistoryStateChangeEvent> listener)"})," registers a listener that gets triggered when the state changes, such as when the user clicks the browser's back or forward buttons. This method sets up a listener for the browser's ",(0,s.jsx)(n.code,{children:"popstate"})," event, allowing your app to respond to user actions or programmatically triggered state changes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'history.addHistoryStateChangeListener(event -> {\n    System.out.println("History state changed to: " + event.getLocation().getFullURI());\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"Effectively managing state allows you to create apps that respond dynamically to user actions. Users can navigate through your app without losing context, making for a smoother and more intuitive experience. Additionally, saving state enables advanced features like restoring view positions, maintaining filter or sort settings, and supporting deep linking\u2014all of which contribute to a more engaging and reliable app."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);