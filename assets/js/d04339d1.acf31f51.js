"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[7977],{7642:(a,i,e)=>{e.r(i),e.d(i,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var t=e(5893),n=e(1151);const o={sidebar_position:6,title:"Jakarta Validation"},r=void 0,s={id:"data-binding/validation/jakarta-validation",title:"Jakarta Validation",description:"Java Bean Validation is widely recognized as the standard for integrating validation logic into Java applications. It utilizes a uniform approach to validation by allowing developers to annotate domain model properties with declarative validation constraints. These constraints are enforced at runtime, with options for both built-in and custom-defined rules.",source:"@site/docs/data-binding/validation/jakarta-validation.md",sourceDirName:"data-binding/validation",slug:"/data-binding/validation/jakarta-validation",permalink:"/docs/data-binding/validation/jakarta-validation",draft:!1,unlisted:!1,editUrl:"https://github.com/webforj/webforj-docs/tree/website/docs/data-binding/validation/jakarta-validation.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Jakarta Validation"},sidebar:"documentationSidebar",previous:{title:"Triggers",permalink:"/docs/data-binding/validation/triggers"},next:{title:"Transformation",permalink:"/docs/data-binding/transformation"}},d={},l=[{value:"Installation",id:"installation",level:2},{value:"The <code>JakartaValidator</code>",id:"the-jakartavalidator",level:2},{value:"Activating <code>JakartaValidator</code>",id:"activating-jakartavalidator",level:3},{value:"Defining constraints for bean properties",id:"defining-constraints-for-bean-properties",level:3}];function c(a){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,n.a)(),...a.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.a,{href:"https://beanvalidation.org/",children:"Java Bean Validation"})," is widely recognized as the standard for integrating validation logic into Java applications. It utilizes a uniform approach to validation by allowing developers to annotate domain model properties with declarative validation constraints. These constraints are enforced at runtime, with options for both built-in and custom-defined rules."]}),"\n",(0,t.jsxs)(i.p,{children:["webforJ seamlessly integrates with Bean Validation through the ",(0,t.jsx)(i.code,{children:"JakartaValidator"})," adapter, providing robust support out of the box."]}),"\n",(0,t.jsx)(i.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsxs)(i.p,{children:["It's necessary to include a compatible implementation, such as ",(0,t.jsx)(i.a,{href:"https://hibernate.org/validator/",children:"Hibernate Validator"}),", in your classpath. If your environment doesn't come with this implementation by default, you can add it manually by using the following Maven dependencies:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>8.0.1.Final</version>\n</dependency>\n<dependency>\n    <groupId>org.glassfish.expressly</groupId>\n    <artifactId>expressly</artifactId>\n    <version>5.0.0</version>\n</dependency>\n"})}),"\n",(0,t.jsxs)(i.h2,{id:"the-jakartavalidator",children:["The ",(0,t.jsx)(i.code,{children:"JakartaValidator"})]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"JakartaValidator"})," class serves as an adapter, bridging the webforJ binding context with Jakarta Validation. This integration enables the use of complex validation rules directly via annotations in the bean class."]}),"\n",(0,t.jsxs)(i.h3,{id:"activating-jakartavalidator",children:["Activating ",(0,t.jsx)(i.code,{children:"JakartaValidator"})]}),"\n",(0,t.jsxs)(i.p,{children:["To activate the ",(0,t.jsx)(i.code,{children:"JakartaValidator"})," across the entire context, you typically use the ",(0,t.jsx)(i.code,{children:"useJakartaValidator"})," parameter when constructing the ",(0,t.jsx)(i.code,{children:"BindingContext"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"BindingContext<User> context = new BindingContext<>(User.class, true);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"defining-constraints-for-bean-properties",children:"Defining constraints for bean properties"}),"\n",(0,t.jsx)(i.p,{children:"Annotation-based constraints are directly applied within the bean class to specify validation conditions, as illustrated in the example below:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'public class Hero {\n  @NotEmpty(message = "Name cannot be empty")\n  @Length(min = 3, max = 20)\n  private String name;\n\n  @NotEmpty(message = "Unspecified power")\n  @Pattern(regexp = "Fly|Invisible|LaserVision|Speed|Teleportation", message = "Invalid power")\n  private String power;\n\n  // getters and setters\n}\n'})}),"\n",(0,t.jsx)(i.p,{children:"Such constraints are as effective as those set programmatically during the binding initialization, ensuring consistent validation outcomes."}),"\n",(0,t.jsx)(i.admonition,{type:"warning",children:(0,t.jsxs)(i.p,{children:["Currently, the ",(0,t.jsx)(i.code,{children:"JakartaValidator"})," only recognizes constraints that are directly assigned to properties and ignores any validations not directly associated with properties."]})})]})}function p(a={}){const{wrapper:i}={...(0,n.a)(),...a.components};return i?(0,t.jsx)(i,{...a,children:(0,t.jsx)(c,{...a})}):c(a)}}}]);