"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[8820],{9288:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var t=n(4848),i=n(8453);const s={sidebar_position:5,title:"Route Patterns"},a=void 0,o={id:"routing/route-patterns",title:"Route Patterns",description:"Route Patterns are used to define how URLs map to specific views, including dynamic and optional segments, regular expressions, and wildcards. Route patterns enable the framework to match URLs, extract parameters, and generate URLs dynamically. They play a critical role in structuring an app's navigation and component rendering based on the browser's location.",source:"@site/docs/routing/route-patterns.md",sourceDirName:"routing",slug:"/routing/route-patterns",permalink:"/docs/routing/route-patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/webforj/webforj-docs/tree/website/docs/routing/route-patterns.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Route Patterns"},sidebar:"documentationSidebar",previous:{title:"Route Navigation",permalink:"/docs/routing/route-navigation"},next:{title:"Query Parameters",permalink:"/docs/routing/query-parameters"}},d={},l=[{value:"Route pattern syntax",id:"route-pattern-syntax",level:2},{value:"Example of route pattern definitions",id:"example-of-route-pattern-definitions",level:3},{value:"Named parameters",id:"named-parameters",level:2},{value:"Example:",id:"example",level:3},{value:"Optional parameters",id:"optional-parameters",level:2},{value:"Example:",id:"example-1",level:3},{value:"Regular expression constraints",id:"regular-expression-constraints",level:2},{value:"Example:",id:"example-2",level:3},{value:"Wildcard segments",id:"wildcard-segments",level:2},{value:"Example:",id:"example-3",level:3},{value:"Route priority",id:"route-priority",level:2},{value:"How the priority system works",id:"how-the-priority-system-works",level:3},{value:"Example: Conflicting routes",id:"example-conflicting-routes",level:3}];function c(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Route Patterns"})," are used to define how URLs map to specific views, including dynamic and optional segments, regular expressions, and wildcards. Route patterns enable the framework to match URLs, extract parameters, and generate URLs dynamically. They play a critical role in structuring an app's navigation and component rendering based on the browser's location."]}),"\n",(0,t.jsx)(r.h2,{id:"route-pattern-syntax",children:"Route pattern syntax"}),"\n",(0,t.jsx)(r.p,{children:"Route patterns in webforJ are highly flexible, supporting the following features:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Named Parameters:"})," Denoted by ",(0,t.jsx)(r.code,{children:":paramName"}),", they are required unless marked as optional."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Optional Parameters:"})," Denoted by ",(0,t.jsx)(r.code,{children:":paramName?"}),", they can be omitted from the URL."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Wildcard Segments:"})," Represented by ",(0,t.jsx)(r.code,{children:"*"}),", they capture all remaining segments of the URL."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Regular Expressions Constraints:"})," Constraints can be added only to named parameters (for example, ",(0,t.jsx)(r.code,{children:":id<[0-9]+>"}),")."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"example-of-route-pattern-definitions",children:"Example of route pattern definitions"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Route("customer/:id<[0-9]+>/named/:name/*")\npublic class CustomerView extends Composite<Div> implements DidEnterObserver {\n\n  @Override\n  public void onDidEnter(DidEnterEvent event, ParametersBag parameters) {\n    int id = parameters.getInt("id").orElse(0);\n    String name = parameters.getAlpha("name").orElse("Unknown");\n    String extra = parameters.getAlpha("*").orElse("");\n\n    String result =\n        "Customer ID: " + id + "-" +\n        "Name: " + name + "-" +\n        "*: " + extra;\n\n    console().log(result);\n  }\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"In this example:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:":id<[0-9]+>"})," captures a numeric customer ID."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:":name"})," captures a name."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"*"})," captures any additional path segments beyond ",(0,t.jsx)(r.code,{children:"named/:name"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"named-parameters",children:"Named parameters"}),"\n",(0,t.jsxs)(r.p,{children:["Named parameters are defined by prefixing a colon ",(0,t.jsx)(r.code,{children:":"})," to the parameter name in the pattern. They're required unless marked as optional. Named parameters can also have regular expression ",(0,t.jsx)(r.a,{href:"#regular-expression-constraints",children:"constraints"})," to validate the values."]}),"\n",(0,t.jsx)(r.h3,{id:"example",children:"Example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Route("product/:id")\npublic class ProductView extends Composite<Div> {\n  // Component logic here\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["This pattern matches URLs like ",(0,t.jsx)(r.code,{children:"/product/123"})," where ",(0,t.jsx)(r.code,{children:"id"})," is ",(0,t.jsx)(r.code,{children:"123"})]}),"\n",(0,t.jsx)(r.h2,{id:"optional-parameters",children:"Optional parameters"}),"\n",(0,t.jsxs)(r.p,{children:["Optional parameters are indicated by adding a ",(0,t.jsx)(r.code,{children:"?"})," after the parameter name. These segments aren't required and can be omitted from the URL."]}),"\n",(0,t.jsx)(r.h3,{id:"example-1",children:"Example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Route("order/:id?<[0-9]+>")\npublic class OrderView extends Composite<Div> implements DidEnterObserver {\n\n  @Override\n  public void onDidEnter(DidEnterEvent event, ParametersBag parameters) {\n    parameters.getInt("id").ifPresentOrElse(\n      id -> console().log("Order ID: " + id),\n      () -> console().log("No Order ID was provided")\n    );\n  }\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["This pattern matches both ",(0,t.jsx)(r.code,{children:"/order/123"})," to include a numeric value to be included, and ",(0,t.jsx)(r.code,{children:"/order"}),", allowing the omission of a numeric value when ",(0,t.jsx)(r.code,{children:"/order"})," is entered."]}),"\n",(0,t.jsx)(r.h2,{id:"regular-expression-constraints",children:"Regular expression constraints"}),"\n",(0,t.jsxs)(r.p,{children:["You can apply regular expression constraints to parameters by adding them within angle brackets ",(0,t.jsx)(r.code,{children:"<>"}),". This allows you to specify stricter matching rules for parameters."]}),"\n",(0,t.jsx)(r.h3,{id:"example-2",children:"Example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Route("product/:code<[A-Z]{3}-[0-9]{4}>")\npublic class ProductView extends Composite<FlexLayout> implements DidEnterObserver {\n\n  @Override\n  public void onDidEnter(DidEnterEvent event, ParametersBag parameters) {\n    parameters.get("code").ifPresentOrElse(\n      code -> console().log("Product code: " + code),\n      () -> console().error("Product code not found"));\n  }\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["This pattern only matches product codes in the format ",(0,t.jsx)(r.code,{children:"ABC-1234"}),". For example, ",(0,t.jsx)(r.code,{children:"/product/XYZ-5678"})," will match, but ",(0,t.jsx)(r.code,{children:"/product/abc-5678"})," won't."]}),"\n",(0,t.jsx)(r.h2,{id:"wildcard-segments",children:"Wildcard segments"}),"\n",(0,t.jsx)(r.p,{children:"Wildcards can be used to capture entire paths following a specific route segment, but they can only appear as the final segment in the pattern, resolving all subsequent values in the URL. For better readability, wildcard segments can be named. However, unlike named parameters, wildcard segments can't have any constraints."}),"\n",(0,t.jsx)(r.h3,{id:"example-3",children:"Example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Route("files/:pathname*")\npublic class FileManagerView extends Composite<Div> implements DidEnterObserver {\n\n  @Override\n  public void onDidEnter(DidEnterEvent event, ParametersBag parameters) {\n    parameters.get("pathname").ifPresentOrElse(\n      pathname -> console().log("FileManagerView: " + pathname),\n      () -> console().log("FileManagerView: No pathname parameter")\n    );\n  }\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["This pattern matches any URL starting with ",(0,t.jsx)(r.code,{children:"/files"})," and captures the rest of the path as a wildcard."]}),"\n",(0,t.jsx)(r.h2,{id:"route-priority",children:"Route priority"}),"\n",(0,t.jsxs)(r.p,{children:["When multiple routes match a given URL, the priority attribute of a route determines which route is selected first. This is especially useful when two or more routes overlap in their path patterns, and you need a way to control which one is given precedence. The priority attribute is available in both ",(0,t.jsx)(r.code,{children:"@Route"})," and ",(0,t.jsx)(r.code,{children:"@RouteAlias"})," annotations."]}),"\n",(0,t.jsx)(r.h3,{id:"how-the-priority-system-works",children:"How the priority system works"}),"\n",(0,t.jsx)(r.p,{children:"The priority attribute allows the router to determine the order in which routes are evaluated when multiple routes could match a given URL. Routes are sorted based on their priority values, with higher priority (lower numeric values) being matched first. This ensures that more specific routes take precedence over more general ones."}),"\n",(0,t.jsx)(r.p,{children:"If two routes share the same priority, the router resolves the conflict by selecting the route that was registered first. This mechanism ensures the correct route is chosen, even when multiple routes overlap in their URL patterns."}),"\n",(0,t.jsx)(r.admonition,{title:"Default Priority",type:"info",children:(0,t.jsxs)(r.p,{children:["By default, all routes are assigned a priority of ",(0,t.jsx)(r.code,{children:"10"}),"."]})}),"\n",(0,t.jsx)(r.h3,{id:"example-conflicting-routes",children:"Example: Conflicting routes"}),"\n",(0,t.jsx)(r.p,{children:"Consider a scenario where two routes match similar URL patterns:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Route(value = "products/:category", priority = 9)\npublic class ProductCategoryView extends Composite<Div> implements DidEnterObserver {\n  @Override\n  public void onDidEnter(DidEnterEvent event, ParametersBag parameters) {\n    String category = parameters.get("category").orElse("unknown");\n    console().log("Viewing category: " + category);\n  }\n}\n\n@Route(value = "products/:category/:productId?<[0-9]+>")\npublic class ProductView extends Composite<Div> implements DidEnterObserver {\n  @Override\n  public void onDidEnter(DidEnterEvent event, ParametersBag parameters) {\n    String productId = parameters.get("productId").orElse("unknown");\n    console().log("Viewing product: " + productId);\n  }\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"Here\u2019s how the priority system helps resolve conflicts:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"ProductCategoryView"})})," matches URLs like ",(0,t.jsx)(r.code,{children:"/products/electronics"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"ProductView"})})," matches more specific URLs like ",(0,t.jsx)(r.code,{children:"/products/electronics/123"}),", where ",(0,t.jsx)(r.code,{children:"123"})," is the product ID."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["In this case, both routes could match the URL ",(0,t.jsx)(r.code,{children:"/products/electronics"}),". However, because ",(0,t.jsx)(r.code,{children:"ProductCategoryView"})," has a higher priority (priority = 9), it will be matched first when there is no ",(0,t.jsx)(r.code,{children:"productId"})," in the URL. For URLs like ",(0,t.jsx)(r.code,{children:"/products/electronics/123"}),", ",(0,t.jsx)(r.code,{children:"ProductView"})," will be matched due to the presence of the ",(0,t.jsx)(r.code,{children:"productId"})," parameter."]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var t=n(6540);const i={},s=t.createContext(i);function a(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);