"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[8694],{4466:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var t=i(5893),n=i(1151);const s={sidebar_position:2,title:"Validators"},d=void 0,o={id:"data-binding/validation/validators",title:"Validators",description:"Validators checks data within your UI components against defined constraints before committing this data to the data model. You can apply validators to ensure that data meets certain criteria, such as being within a specified range, matching a pattern, or not being empty.",source:"@site/docs/data-binding/validation/validators.md",sourceDirName:"data-binding/validation",slug:"/data-binding/validation/validators",permalink:"/docs/data-binding/validation/validators",draft:!1,unlisted:!1,editUrl:"https://github.com/webforj/webforj-docs/tree/website/docs/data-binding/validation/validators.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Validators"},sidebar:"documentationSidebar",previous:{title:"Validation",permalink:"/docs/data-binding/validation/overview"},next:{title:"Reporters",permalink:"/docs/data-binding/validation/reporters"}},r={},l=[{value:"Adding validators",id:"adding-validators",level:2},{value:"Implementing validators",id:"implementing-validators",level:2},{value:"Using validators in bindings",id:"using-validators-in-bindings",level:2},{value:"Overriding validator messages",id:"overriding-validator-messages",level:2}];function c(e){const a={admonition:"admonition",code:"code",h2:"h2",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.p,{children:"Validators checks data within your UI components against defined constraints before committing this data to the data model. You can apply validators to ensure that data meets certain criteria, such as being within a specified range, matching a pattern, or not being empty."}),"\n",(0,t.jsx)(a.p,{children:"Validations are configured per binding, allowing specific rules to apply to each data point individually. This setup ensures that each piece of data undergoes validation according to its own requirements."}),"\n",(0,t.jsx)(a.h2,{id:"adding-validators",children:"Adding validators"}),"\n",(0,t.jsxs)(a.p,{children:["Add validators to a binding using the ",(0,t.jsx)(a.code,{children:"useValidator"})," method on the ",(0,t.jsx)(a.code,{children:"BindingBuilder"}),"."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'context.bind(nameTextField, "name")\n    .useValidator(value -> !value.isEmpty(), "Name cannot be empty")\n    .useValidator(value -> value.length() >= 3, "Name must be at least 3 characters long")\n    .add();\n'})}),"\n",(0,t.jsx)(a.p,{children:"In the example above, two validators verify that the name isn't empty and that it contains at least three characters."}),"\n",(0,t.jsx)(a.admonition,{title:"Validators processing",type:"tip",children:(0,t.jsx)(a.p,{children:"There is no limit to the number of validators you can add per binding. The binding applies the validators by the order of insertion, and stops at the first violation."})}),"\n",(0,t.jsx)(a.h2,{id:"implementing-validators",children:"Implementing validators"}),"\n",(0,t.jsxs)(a.p,{children:["You can create custom reusable validators by implementing the ",(0,t.jsx)(a.code,{children:"Validator<T>"})," interface, where ",(0,t.jsx)(a.code,{children:"T"})," is the type of data you want to validate. This setup involves defining the validate method, which checks the data and returns a ",(0,t.jsx)(a.code,{children:"ValidationResult"}),"."]}),"\n",(0,t.jsx)(a.p,{children:"Here\u2019s an example of a reusable validator that checks if an user's email is valid."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'import com.webforj.data.validation.server.ValidationResult;\nimport com.webforj.data.validation.server.validator.Validator;\n\npublic class EmailValidator implements Validator<String> {\n  private static final String PATTERN = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6}$";\n\n  @Override\n  public ValidationResult validate(String value) {\n    if (value.matches(PATTERN)) {\n        return ValidationResult.valid();\n    } else {\n        return ValidationResult.invalid("Invalid email address");\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(a.h2,{id:"using-validators-in-bindings",children:"Using validators in bindings"}),"\n",(0,t.jsx)(a.p,{children:"Once you have defined a validator, you can easily apply it to any relevant bindings within your app. This is particularly useful for components that require common validation rules across different parts of your app, such as user email addresses, or password strength."}),"\n",(0,t.jsxs)(a.p,{children:["To apply the ",(0,t.jsx)(a.code,{children:"EmailValidator"})," to a binding:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'BindingContext<User> context = new BindingContext<>(User.class);\ncontext.bind(ageField, "age")\n    .useValidator(new EmailValidator())\n    .add();\n'})}),"\n",(0,t.jsx)(a.h2,{id:"overriding-validator-messages",children:"Overriding validator messages"}),"\n",(0,t.jsx)(a.p,{children:"You can customize the error messages of validators at the point of binding to a specific UI component. This allows you to provide more detailed or contextually relevant information to the user if the validation fails. Custom messages are particularly useful when the same validator applies to multiple components but requires different user guidance based on the context in which it is used."}),"\n",(0,t.jsx)(a.p,{children:"Here's how to override the default message of a reusable validator in a binding:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'BindingContext<User> context = new BindingContext<>(User.class);\ncontext.bind(emailField, "email")\n    .useValidator(\n        Validator.from(new EmailValidator(), "Custom message for invalid email address"))\n    .add();\n'})}),"\n",(0,t.jsxs)(a.p,{children:["In the example above, the code applies the ",(0,t.jsx)(a.code,{children:"EmailValidator"})," to an email field with a custom error message specifically tailored for that field. This allows for a more directed and helpful user experience if the validation fails."]}),"\n",(0,t.jsxs)(a.admonition,{type:"tip",children:[(0,t.jsxs)(a.mdxAdmonitionTitle,{children:["Understanding ",(0,t.jsx)(a.code,{children:"Validator.from"})]}),(0,t.jsxs)(a.p,{children:["The ",(0,t.jsx)(a.code,{children:"Validator.from"})," method wraps a passed validator with a new one, allowing you to specify a custom error message in case the validator doesn't support customized messages. This technique is particularly useful when you need to apply the same validation logic across multiple components but with distinct, context-specific error messages for each instance."]})]})]})}function h(e={}){const{wrapper:a}={...(0,n.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);