"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[643],{3717:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var o=n(4848),i=n(8453);const s={sidebar_position:3,title:"Route Outlets"},r=void 0,a={id:"routing/route-hierarchy/route-outlets",title:"Route Outlets",description:"An outlet is a designated component, either a route layout or a route view, where child routes are dynamically rendered. It defines where the content of the child route will appear within the parent route. Outlets are fundamental to creating modular, nested UIs and flexible navigation structures.",source:"@site/docs/routing/route-hierarchy/route-outlets.md",sourceDirName:"routing/route-hierarchy",slug:"/routing/route-hierarchy/route-outlets",permalink:"/docs/routing/route-hierarchy/route-outlets",draft:!1,unlisted:!1,editUrl:"https://github.com/webforj/webforj-docs/tree/website/docs/routing/route-hierarchy/route-outlets.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Route Outlets"},sidebar:"documentationSidebar",previous:{title:"Nested Routes",permalink:"/docs/routing/route-hierarchy/nested-routes"},next:{title:"Navigational Frame Titles",permalink:"/docs/routing/navigational-frame-titles"}},l={},c=[{value:"Defining an outlet",id:"defining-an-outlet",level:2},{value:"Example:",id:"example",level:3},{value:"Outlet lifecycle",id:"outlet-lifecycle",level:2},{value:"Custom outlets",id:"custom-outlets",level:2},{value:"Key methods in <code>RouteOutlet</code>:",id:"key-methods-in-routeoutlet",level:3},{value:"Caching outlet components",id:"caching-outlet-components",level:2},{value:"How <code>PersistentRouteOutlet</code> works:",id:"how-persistentrouteoutlet-works",level:3},{value:"Example of <code>PersistentRouteOutlet</code> implementation:",id:"example-of-persistentrouteoutlet-implementation",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["An ",(0,o.jsx)(t.strong,{children:"outlet"})," is a designated component, either a ",(0,o.jsx)(t.a,{href:"./route-types#layout-routes",children:"route layout"})," or a ",(0,o.jsx)(t.a,{href:"./route-types#view-routes",children:"route view"}),", where child routes are dynamically rendered. It defines where the content of the child route will appear within the parent route. Outlets are fundamental to creating modular, nested UIs and flexible navigation structures."]}),"\n",(0,o.jsx)(t.h2,{id:"defining-an-outlet",children:"Defining an outlet"}),"\n",(0,o.jsxs)(t.p,{children:["Outlets are typically implemented using container components that can hold and manage child content. In webforJ, any component that implements the ",(0,o.jsx)(t.code,{children:"HasComponents"})," interface, or a composite of such components, can serve as an outlet. For example, ",(0,o.jsx)(t.a,{href:"../../components/flex-layout",children:(0,o.jsx)(t.code,{children:"FlexLayout"})})," implements the ",(0,o.jsx)(t.code,{children:"HasComponents"})," interface, making it a valid outlet for child routes."]}),"\n",(0,o.jsxs)(t.p,{children:["If no outlet is explicitly defined for a route, the first ",(0,o.jsx)(t.code,{children:"Frame"})," of the app is used as the default outlet. This behavior ensures that every child route has a place to be rendered."]}),"\n",(0,o.jsx)(t.admonition,{title:"Frame Management",type:"tip",children:(0,o.jsxs)(t.p,{children:["In applications with multiple frames, you can specify which frame to use as the outlet for child routes by setting the ",(0,o.jsx)(t.code,{children:"frame"})," attribute in the ",(0,o.jsx)(t.code,{children:"@Route"})," annotation. The ",(0,o.jsx)(t.code,{children:"frame"})," attribute accepts the name of the frame to be used for rendering."]})}),"\n",(0,o.jsx)(t.h3,{id:"example",children:"Example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'@Route\npublic class MainLayout extends Composite<AppLayout> {\n  public MainLayout() {\n    setHeader();\n    setDrawer();\n  }\n}\n\n@Route(outlet = MainLayout.class)\npublic class DashboardView extends Composite<Div> {\n  public DashboardView() {\n    getBoundComponent().add(new H1("Dashboard Content"));\n  }\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"In this example:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"MainLayout"})," acts as the layout container, but since no specific outlet is defined, the app's default ",(0,o.jsx)(t.code,{children:"Frame"})," is used."]}),"\n",(0,o.jsxs)(t.li,{children:["The ",(0,o.jsx)(t.code,{children:"DashboardView"})," is rendered within ",(0,o.jsx)(t.code,{children:"MainLayout"})," using the default outlet (content area) of the ",(0,o.jsx)(t.code,{children:"AppLayout"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Thus, child routes of ",(0,o.jsx)(t.code,{children:"MainLayout"})," will automatically be rendered in the content slot of ",(0,o.jsx)(t.code,{children:"AppLayout"}),", unless a different outlet or frame is specified."]}),"\n",(0,o.jsx)(t.h2,{id:"outlet-lifecycle",children:"Outlet lifecycle"}),"\n",(0,o.jsx)(t.p,{children:"Outlets are closely tied to the lifecycle of routes. When the active route changes, the outlet updates its content dynamically by injecting the appropriate child component and removing any components that are no longer needed. This ensures that only the relevant views are rendered at any given time."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Creation"}),": Outlets are initialized before child components are created."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Content Injection"}),": When a child route is matched, its component is injected into the outlet."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Updating"}),": When navigating between routes, the outlet updates its content, injecting the new child component and removing any outdated components."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"custom-outlets",children:"Custom outlets"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"RouteOutlet"})," interface is responsible for managing the lifecycle of route components, determining how components are rendered and removed. Any component that implements this interface can act as an outlet for other components."]}),"\n",(0,o.jsxs)(t.h3,{id:"key-methods-in-routeoutlet",children:["Key methods in ",(0,o.jsx)(t.code,{children:"RouteOutlet"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"showRouteContent(Component component)"})}),": Responsible for rendering the provided component in the outlet. This is called when the router matches a route, and the child component needs to be displayed."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"removeRouteContent(Component component)"})}),": Handles the removal of the component from the outlet, typically called when navigating away from the current route."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["By implementing ",(0,o.jsx)(t.code,{children:"RouteOutlet"}),", developers can control how routes are injected into specific areas of the app. for instance"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"import com.webforj.router.RouteOutlet;\n\npublic class MainLayout extends Composite<AppLayout> implements RouteOutlet {\n\n  @Override\n  public void showRouteContent(Component component) {\n    AppLayout layout = getBoundComponent();\n    layout.addToDrawer(component);\n  }\n\n  @Override\n  public void removeRouteContent(Component component) {\n    AppLayout layout = getBoundComponent();\n    layout.remove(component);\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In this example, the ",(0,o.jsx)(t.code,{children:"MainLayout"})," class implements the ",(0,o.jsx)(t.code,{children:"RouteOutlet"})," interface, allowing components to be added or removed from the AppLayout's drawer dynamically based on the route navigation instead\nof the default content area defined in the ",(0,o.jsx)(t.code,{children:"AppLayout"})," component"]}),"\n",(0,o.jsx)(t.h2,{id:"caching-outlet-components",children:"Caching outlet components"}),"\n",(0,o.jsxs)(t.p,{children:["By default, outlets dynamically add and remove components when navigating to and away from routes. However, in certain cases\u2014particularly for views with complex components\u2014it may be preferable to toggle the visibility of components rather than completely removing them from the DOM. This is where the ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," comes into play, allowing components to remain in memory and simply be hidden or shown, instead of being destroyed and recreated."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," caches rendered components, keeping them in memory when the user navigates away. This improves performance by avoiding unnecessary component destruction and recreation, which is especially beneficial for applications where users frequently switch between views."]}),"\n",(0,o.jsxs)(t.h3,{id:"how-persistentrouteoutlet-works",children:["How ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," works:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Component Caching"}),": It maintains an in-memory cache of all components that have been rendered within the outlet."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Visibility Toggle"}),": Instead of removing components from the DOM, it hides them when navigating away from a route."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Component Restoration"}),": When the user navigates back to a previously cached route, the component is simply shown again without the need for recreation."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["This behavior is particularly useful for complex UIs where constant re-rendering of components can degrade performance. However, to make this toggling of visibility work, the managed components must implement the ",(0,o.jsx)(t.code,{children:"HasVisibility"})," interface, which allows the ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," to control their visibility."]}),"\n",(0,o.jsxs)(t.admonition,{type:"tip",children:[(0,o.jsxs)(t.mdxAdmonitionTitle,{children:["When to use ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})]}),(0,o.jsxs)(t.p,{children:["Use ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," when creating and destroying components frequently leads to performance bottlenecks in your app. It's generally recommended to allow the default behavior of creating and destroying components during route transitions, as this helps avoid potential bugs and issues related to maintaining consistent state. However, in scenarios where performance is critical and components are complex or expensive to recreate, ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," can offer significant improvements by caching components and managing their visibility."]})]}),"\n",(0,o.jsxs)(t.h3,{id:"example-of-persistentrouteoutlet-implementation",children:["Example of ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," implementation:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"@Route\npublic class MainLayout extends Composite<AppLayout> implements RouteOutlet {\n  PersistentRouteOutlet outlet = new PersistentRouteOutlet(this);\n\n  public MainLayout() {\n    setHeader();\n    setDrawer();\n  }\n\n  @Override\n  public void removeRouteContent(Component component) {\n    outlet.removeRouteContent(component);\n  }\n\n  @Override\n  public void showRouteContent(Component component) {\n    outlet.showRouteContent(component);\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In this example, ",(0,o.jsx)(t.code,{children:"MainLayout"})," uses ",(0,o.jsx)(t.code,{children:"PersistentRouteOutlet"})," to manage its child routes. When navigating between routes, components aren't removed from the DOM but instead hidden, ensuring that they remain available for quick re-rendering when the user navigates back. This approach significantly enhances performance, especially for views with complex content or heavy resource usage."]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);