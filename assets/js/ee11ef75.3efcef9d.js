"use strict";(self.webpackChunkdwcj_documentation=self.webpackChunkdwcj_documentation||[]).push([[1294],{9614:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"data-binding/validation/triggers","title":"Triggers","description":"By default, bindings automatically revalidate components when users modify their data, such as entering new text, checking a checkbox, or selecting a new option in a radio button. If you prefer to turn off automatic validations and only report them when writing to the data model, you can configure the binding to turn them off. This gives you control over when and how validations occur, allowing you to manage validations according to specific app needs or user interactions.","source":"@site/docs/data-binding/validation/triggers.md","sourceDirName":"data-binding/validation","slug":"/data-binding/validation/triggers","permalink":"/docs/data-binding/validation/triggers","draft":false,"unlisted":false,"editUrl":"https://github.com/webforj/webforj-docs/tree/website/docs/data-binding/validation/triggers.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Triggers"},"sidebar":"documentationSidebar","previous":{"title":"Context Results","permalink":"/docs/data-binding/validation/context-results"},"next":{"title":"Jakarta Validation","permalink":"/docs/data-binding/validation/jakarta-validation"}}');var r=a(4848),i=a(8453),o=a(1470),s=a(9365);const l={sidebar_position:5,title:"Triggers"},d=void 0,u={},c=[{value:"Revalidation",id:"revalidation",level:2}];function h(e){const t={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"By default, bindings automatically revalidate components when users modify their data, such as entering new text, checking a checkbox, or selecting a new option in a radio button. If you prefer to turn off automatic validations and only report them when writing to the data model, you can configure the binding to turn them off. This gives you control over when and how validations occur, allowing you to manage validations according to specific app needs or user interactions."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'BindingContext<User> context = new BindingContext<>(User.class);\ncontext.bind(emailField, "email")\n    .useValidator(\n        Validator.from(new EmailValidator(), "Custom message for invalid email address"))\n    .autoValidate(false)\n    .add();\n'})}),"\n",(0,r.jsx)(t.p,{children:"It's also possible to turn of the auto-validations for the whole context."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"BindingContext<User> context = new BindingContext<>(User.class);\ncontext.setAutoValidate(false);\n"})}),"\n",(0,r.jsxs)(t.admonition,{title:"Value Change Mode",type:"tip",children:[(0,r.jsxs)(t.p,{children:["Some components, like the field components, implement the ",(0,r.jsx)(t.code,{children:"ValueChangeModeAware"})," interface, which lets you control when the system reports a ",(0,r.jsx)(t.code,{children:"ValueChangeEvent"}),". For instance, you can set field components to report value changes only on blur. This configuration reduces the frequency of validations, optimizing performance and enhancing the user experience by focusing validations on moments when the user completes an input session, rather than during active typing."]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:" emailField.setValueChangeMode(ValueChangeMode.ON_BLUR);\n"})})]}),"\n",(0,r.jsx)(t.h2,{id:"revalidation",children:"Revalidation"}),"\n",(0,r.jsx)(t.p,{children:"While validations typically trigger automatically during data writing, you can also invoke them manually to verify the state of data without attempting to write it to the model. This manual approach is particularly useful in scenarios where you want to enable or turn off features based on the validity of the form data without making an update."}),"\n",(0,r.jsx)(t.p,{children:"Consider a classic example of a Trip Date Chooser, where a user must select two dates: the start date and the end date of a trip. It's not valid to choose an end date that occurs before the start date, or a start date that occurs after the end date. You can resolve these dependencies by triggering validations manually:"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(s.A,{value:"TripBooking",label:"TripBooking.java",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",metastring:"showLineNumbers",children:'public class TripBooking extends App {\n  DateTimeField startDateField = new DateTimeField("Start Date");\n  DateTimeField endDateField = new DateTimeField("End Date");\n  FlexLayout layout = FlexLayout.create(startDateField, endDateField).vertical().build().setStyle("margin", "20px auto")\n      .setMaxWidth("400px");\n\n  LocalDateTime startDate;\n  LocalDateTime endDate;\n\n  @Override\n  public void run() throws WebforjException {\n    BindingContext<Trip> context = new BindingContext<>(Trip.class);\n    context.bind(startDateField, "startDate")\n        .useValidator(Objects::nonNull, "Start date is required")\n        .useValidator(value -> endDate != null && value.isBefore(endDate),\n            "Start date must be before end date")\n        .add();\n\n    context.bind(endDateField, "endDate")\n        .useValidator(Objects::nonNull, "End date is required")\n        .useValidator(value -> startDate != null && value.isAfter(startDate),\n            "End date must be after start date")\n        .add();\n\n    startDateField.setValueChangeMode(ValueChangeMode.ON_BLUR);\n    startDateField.addValueChangeListener(event -> {\n      startDate = event.getValue();\n      context.getBinding("endDate").validate();\n    });\n\n    endDateField.setValueChangeMode(ValueChangeMode.ON_BLUR);\n    endDateField.addValueChangeListener(event -> {\n      endDate = event.getValue();\n      context.getBinding("startDate").validate();\n    });\n\n    Frame frame = new Frame();\n    frame.add(layout);\n  }\n}\n'})})}),(0,r.jsx)(s.A,{value:"Trip",label:"Trip.java",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",metastring:"showLineNumbers",children:"public class Trip {\n  private LocalDateTime startDate;\n  private LocalDateTime endDate;\n\n  public LocalDateTime getStartDate() {\n    return startDate;\n  }\n\n  public void setStartDate(LocalDateTime startDate) {\n    this.startDate = startDate;\n  }\n\n  public LocalDateTime getEndDate() {\n    return endDate;\n  }\n\n  public void setEndDate(LocalDateTime endDate) {\n    this.endDate = endDate;\n  }\n}\n"})})})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},9365:(e,t,a)=>{a.d(t,{A:()=>o});a(6540);var n=a(8215);const r={tabItem:"tabItem_Ymn6"};var i=a(4848);function o(e){let{children:t,hidden:a,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,n.A)(r.tabItem,o),hidden:a,children:t})}},1470:(e,t,a)=>{a.d(t,{A:()=>D});var n=a(6540),r=a(8215),i=a(3104),o=a(6347),s=a(205),l=a(7485),d=a(1682),u=a(679);function c(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return c(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}(a);return function(e){const t=(0,d.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function p(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:a}=e;const r=(0,o.W6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l.aZ)(i),(0,n.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(r.location.search);t.set(i,e),r.replace({...r.location,search:t.toString()})}),[i,r])]}function g(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,i=h(e),[o,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[d,c]=m({queryString:a,groupId:r}),[g,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,i]=(0,u.Dv)(a);return[r,(0,n.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:r}),b=(()=>{const e=d??g;return p({value:e,tabValues:i})?e:null})();(0,s.A)((()=>{b&&l(b)}),[b]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),f(e)}),[c,f,i]),tabValues:i}}var f=a(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=a(4848);function x(e){let{className:t,block:a,selectedValue:n,selectValue:o,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.a_)(),u=e=>{const t=e.currentTarget,a=l.indexOf(t),r=s[a].value;r!==n&&(d(t),o(r))},c=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;t=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;t=l[a]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":a},t),children:s.map((e=>{let{value:t,label:a,attributes:i}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:c,onClick:u,...i,className:(0,r.A)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":n===t}),children:a??t},t)}))})}function w(e){let{lazy:t,children:a,selectedValue:i}=e;const o=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===i));return e?(0,n.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function y(e){const t=g(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",b.tabList),children:[(0,v.jsx)(x,{...t,...e}),(0,v.jsx)(w,{...t,...e})]})}function D(e){const t=(0,f.A)();return(0,v.jsx)(y,{...e,children:c(e.children)},String(t))}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>s});var n=a(6540);const r={},i=n.createContext(r);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);